{"ast":null,"code":"import _objectSpread from \"/home/kvm-06/github/flork-meme-bank/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport isEqual from 'react-fast-compare';\nimport { lerp, random, randomElement, twoPi } from './utils.js';\nexport const defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0],\n  opacity: [1, 1],\n  enable3DRotation: false\n};\n/**\n * An individual snowflake that will update it's location every call to `update`\n * and draw itself to the canvas every call to `draw`.\n */\nclass Snowflake {\n  /**\n   * A utility function to create a collection of snowflakes\n   * @param canvas The canvas element\n   * @param amount The number of snowflakes\n   * @param config The configuration for each snowflake\n   */\n  static createSnowflakes(canvas, amount, config) {\n    if (!canvas) return [];\n    const snowflakes = [];\n    for (let i = 0; i < amount; i++) {\n      snowflakes.push(new Snowflake(canvas, config));\n    }\n    return snowflakes;\n  }\n  constructor(canvas) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Set custom config\n    this.updateConfig(config);\n    // Setting initial parameters\n    const {\n      radius,\n      wind,\n      speed,\n      rotationSpeed,\n      opacity,\n      enable3DRotation\n    } = this.config;\n    this.params = {\n      x: random(0, canvas.offsetWidth),\n      y: random(-canvas.offsetHeight, 0),\n      rotation: random(0, 360),\n      radius: random(...radius),\n      speed: random(...speed),\n      wind: random(...wind),\n      rotationSpeed: random(...rotationSpeed),\n      nextSpeed: random(...speed),\n      nextWind: random(...wind),\n      nextRotationSpeed: random(...rotationSpeed),\n      opacity: random(...opacity),\n      hasNextOpacity: false,\n      // Initialize 3D rotation parameters\n      rotationX: enable3DRotation ? random(0, 360) : 0,\n      rotationY: enable3DRotation ? random(0, 360) : 0,\n      rotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\n      rotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\n      nextRotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\n      nextRotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n  selectImage() {\n    if (this.config.images && this.config.images.length > 0) {\n      this.image = randomElement(this.config.images);\n    } else {\n      this.image = undefined;\n    }\n  }\n  updateConfig(config) {\n    const previousConfig = this.config;\n    this.config = _objectSpread(_objectSpread({}, defaultConfig), config);\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5);\n    // Update the radius if the config has changed, it won't gradually update on it's own\n    if (this.params && !isEqual(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n      this.params.radius = random(...this.config.radius);\n    }\n    if (!isEqual(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n      this.selectImage();\n    }\n    if ((previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity) && !isEqual(this.config.opacity, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity)) {\n      this.params.hasNextOpacity = true;\n    }\n  }\n  updateTargetParams() {\n    this.params.nextSpeed = random(...this.config.speed);\n    this.params.nextWind = random(...this.config.wind);\n    if (this.image) {\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed);\n    }\n    if (this.config.enable3DRotation) {\n      this.params.nextRotationSpeedX = random(-2.0, 2.0);\n      this.params.nextRotationSpeedY = random(-2.0, 2.0);\n    }\n  }\n  update(offsetWidth, offsetHeight) {\n    let framesPassed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const {\n      x,\n      y,\n      rotation,\n      rotationSpeed,\n      nextRotationSpeed,\n      wind,\n      speed,\n      nextWind,\n      nextSpeed,\n      radius\n    } = this.params;\n    // Update current location, wrapping around if going off the canvas\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2);\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius;\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2);\n    if (this.params.y > offsetHeight + radius) {\n      if (this.params.hasNextOpacity) {\n        this.params.opacity = random(...this.config.opacity);\n        this.params.hasNextOpacity = false;\n      }\n      this.params.y = -radius;\n    }\n    // Apply rotation\n    if (this.image || this.config.enable3DRotation) {\n      this.params.rotation = (rotation + rotationSpeed) % 360;\n    }\n    // Apply 3D rotation if enabled\n    if (this.config.enable3DRotation) {\n      this.params.rotationX = (this.params.rotationX + this.params.rotationSpeedX * framesPassed) % 360;\n      this.params.rotationY = (this.params.rotationY + this.params.rotationSpeedY * framesPassed) % 360;\n    }\n    // Update the wind, speed and rotation towards the desired values\n    this.params.speed = lerp(speed, nextSpeed, 0.01);\n    this.params.wind = lerp(wind, nextWind, 0.01);\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01);\n    if (this.config.enable3DRotation) {\n      this.params.rotationSpeedX = lerp(this.params.rotationSpeedX, this.params.nextRotationSpeedX, 0.01);\n      this.params.rotationSpeedY = lerp(this.params.rotationSpeedY, this.params.nextRotationSpeedY, 0.01);\n    }\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n      this.updateTargetParams();\n      this.framesSinceLastUpdate = 0;\n    }\n  }\n  getImageOffscreenCanvas(image, size) {\n    var _a, _b;\n    if (image instanceof HTMLImageElement && image.loading) return image;\n    let sizes = Snowflake.offscreenCanvases.get(image);\n    if (!sizes) {\n      sizes = {};\n      Snowflake.offscreenCanvases.set(image, sizes);\n    }\n    if (!(size in sizes)) {\n      const canvas = document.createElement('canvas');\n      canvas.width = size;\n      canvas.height = size;\n      (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(image, 0, 0, size, size);\n      sizes[size] = canvas;\n    }\n    return (_b = sizes[size]) !== null && _b !== void 0 ? _b : image;\n  }\n  /**\n   * Applies 3D rotation transform to the canvas context.\n   * This method calculates and applies the transformation matrix for 3D rotation effects.\n   *\n   * @param ctx The canvas context to apply the transform to\n   * @param x The x position to translate to\n   * @param y The y position to translate to\n   */\n  apply3DTransform(ctx, x, y) {\n    if (this.config.enable3DRotation) {\n      const {\n        rotationX,\n        rotationY\n      } = this.params;\n      const rotation = this.params.rotation || 0;\n      // Convert degrees to radians\n      const radX = rotationX * Math.PI / 180;\n      const radY = rotationY * Math.PI / 180;\n      const radZ = rotation * Math.PI / 180;\n      // Calculate 3D rotation matrices\n      const cosX = Math.cos(radX);\n      const sinX = Math.sin(radX);\n      const cosY = Math.cos(radY);\n      const sinY = Math.sin(radY);\n      const cosZ = Math.cos(radZ);\n      const sinZ = Math.sin(radZ);\n      // Combined rotation matrix (Z * Y * X)\n      // This creates a 3D tumbling effect\n      const a = cosZ * cosY;\n      const b = cosZ * sinY * sinX - sinZ * cosX;\n      const c = cosZ * sinY * cosX + sinZ * sinX;\n      const d = sinZ * cosY;\n      // Apply the transform\n      // The arguments for setTransform are: a, b, c, d, e, f\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\n      ctx.setTransform(a, b, c, d, x, y);\n    } else {\n      // Original 2D rotation (only for images)\n      const rotation = this.params.rotation || 0;\n      const radian = rotation * Math.PI / 180;\n      const cos = Math.cos(radian);\n      const sin = Math.sin(radian);\n      // The arguments for setTransform are: a, b, c, d, e, f\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\n      ctx.setTransform(cos, sin, -sin, cos, x, y);\n    }\n  }\n  /**\n   * Draws a circular snowflake to the canvas.\n   *\n   * This method should only be called if our config does not have images.\n   *\n   * This method assumes that a path has already been started on the canvas.\n   * `ctx.beginPath()` should be called before calling this method.\n   *\n   * After calling this method, the fillStyle should be set to the snowflake's\n   * color and `ctx.fill()` should be called to fill the snowflake.\n   *\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\n   *\n   * @param ctx The canvas context to draw to\n   */\n  drawCircle(ctx) {\n    // If 3D rotation is enabled, we need to draw individually with transform\n    // This method is called when 3D rotation is disabled (for performance)\n    ctx.moveTo(this.params.x, this.params.y);\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi);\n  }\n  /**\n   * Draws a circular snowflake with 3D rotation effect to the canvas.\n   *\n   * This method is used when 3D rotation is enabled and images are not being used.\n   *\n   * @param ctx The canvas context to draw to\n   * @param color The color to fill the circle with\n   */\n  drawCircle3D(ctx, color) {\n    const {\n      x,\n      y,\n      radius\n    } = this.params;\n    ctx.save();\n    // Apply 3D rotation transform\n    if (this.config.enable3DRotation) {\n      this.apply3DTransform(ctx, x, y);\n    } else {\n      // No transform needed for circles without 3D rotation\n      ctx.translate(x, y);\n    }\n    // Draw the circle\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, 0, twoPi);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.restore();\n  }\n  /**\n   * Draws an image-based snowflake to the canvas.\n   *\n   * This method should only be called if our config has images.\n   *\n   * @param ctx The canvas context to draw to\n   */\n  drawImage(ctx) {\n    const {\n      x,\n      y,\n      radius\n    } = this.params;\n    // Save the current state to avoid affecting other drawings\n    ctx.save();\n    // Set opacity if needed\n    if (this.params.opacity !== 1) {\n      ctx.globalAlpha = this.params.opacity;\n    }\n    // Apply 3D or 2D rotation transform\n    this.apply3DTransform(ctx, x, y);\n    // Draw the image with the center of the image at the center of the current location\n    const image = this.getImageOffscreenCanvas(this.image, radius);\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius);\n    // Restore the transform\n    ctx.restore();\n  }\n}\nSnowflake.offscreenCanvases = new WeakMap();\nexport default Snowflake;","map":{"version":3,"names":["isEqual","lerp","random","randomElement","twoPi","defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","opacity","enable3DRotation","Snowflake","createSnowflakes","canvas","amount","config","snowflakes","i","push","constructor","arguments","length","undefined","updateConfig","params","x","offsetWidth","y","offsetHeight","rotation","nextSpeed","nextWind","nextRotationSpeed","hasNextOpacity","rotationX","rotationY","rotationSpeedX","rotationSpeedY","nextRotationSpeedX","nextRotationSpeedY","framesSinceLastUpdate","selectImage","images","image","previousConfig","_objectSpread","updateTargetParams","update","framesPassed","getImageOffscreenCanvas","size","HTMLImageElement","loading","sizes","offscreenCanvases","get","set","document","createElement","width","height","_a","getContext","drawImage","_b","apply3DTransform","ctx","radX","Math","PI","radY","radZ","cosX","cos","sinX","sin","cosY","sinY","cosZ","sinZ","a","b","c","d","setTransform","radian","drawCircle","moveTo","arc","drawCircle3D","save","translate","beginPath","fillStyle","fill","restore","globalAlpha","WeakMap"],"sources":["/home/kvm-06/github/flork-meme-bank/node_modules/react-snowfall/src/Snowflake.ts"],"sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement, twoPi } from './utils.js'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n  /**\r\n   * The minimum and maximum opacity of the snowflake image.\r\n   *\r\n   * This value only applies to snowflakes that are using images.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1, 1]`.\r\n   */\r\n  opacity: [number, number]\r\n  /**\r\n   * Enable 3D rotation effect (like falling leaves).\r\n   *\r\n   * When enabled, snowflakes will rotate on X and Y axes in addition to Z axis,\r\n   * creating a more realistic 3D tumbling effect.\r\n   *\r\n   * The default value is `false`.\r\n   */\r\n  enable3DRotation?: boolean\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n  opacity: [1, 1],\r\n  enable3DRotation: false,\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n  opacity: number\r\n  hasNextOpacity: boolean\r\n  // 3D rotation parameters\r\n  rotationX: number\r\n  rotationY: number\r\n  rotationSpeedX: number\r\n  rotationSpeedY: number\r\n  nextRotationSpeedX: number\r\n  nextRotationSpeedY: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  private static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  /**\r\n   * A utility function to create a collection of snowflakes\r\n   * @param canvas The canvas element\r\n   * @param amount The number of snowflakes\r\n   * @param config The configuration for each snowflake\r\n   */\r\n  static createSnowflakes(canvas: HTMLCanvasElement | null, amount: number, config: SnowflakeConfig): Snowflake[] {\r\n    if (!canvas) return []\r\n\r\n    const snowflakes: Snowflake[] = []\r\n\r\n    for (let i = 0; i < amount; i++) {\r\n      snowflakes.push(new Snowflake(canvas, config))\r\n    }\r\n\r\n    return snowflakes\r\n  }\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed, opacity, enable3DRotation } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...speed),\r\n      nextWind: random(...wind),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n      opacity: random(...opacity),\r\n      hasNextOpacity: false,\r\n      // Initialize 3D rotation parameters\r\n      rotationX: enable3DRotation ? random(0, 360) : 0,\r\n      rotationY: enable3DRotation ? random(0, 360) : 0,\r\n      rotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      rotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      nextRotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      nextRotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n\r\n    if (previousConfig?.opacity && !isEqual(this.config.opacity, previousConfig?.opacity)) {\r\n      this.params.hasNextOpacity = true\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n    if (this.config.enable3DRotation) {\r\n      this.params.nextRotationSpeedX = random(-2.0, 2.0)\r\n      this.params.nextRotationSpeedY = random(-2.0, 2.0)\r\n    }\r\n  }\r\n\r\n  public update(offsetWidth: number, offsetHeight: number, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2)\r\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2)\r\n    if (this.params.y > offsetHeight + radius) {\r\n      if (this.params.hasNextOpacity) {\r\n        this.params.opacity = random(...this.config.opacity)\r\n        this.params.hasNextOpacity = false\r\n      }\r\n      this.params.y = -radius\r\n    }\r\n\r\n    // Apply rotation\r\n    if (this.image || this.config.enable3DRotation) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Apply 3D rotation if enabled\r\n    if (this.config.enable3DRotation) {\r\n      this.params.rotationX = (this.params.rotationX + this.params.rotationSpeedX * framesPassed) % 360\r\n      this.params.rotationY = (this.params.rotationY + this.params.rotationSpeedY * framesPassed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.config.enable3DRotation) {\r\n      this.params.rotationSpeedX = lerp(this.params.rotationSpeedX, this.params.nextRotationSpeedX, 0.01)\r\n      this.params.rotationSpeedY = lerp(this.params.rotationSpeedY, this.params.nextRotationSpeedY, 0.01)\r\n    }\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  /**\r\n   * Applies 3D rotation transform to the canvas context.\r\n   * This method calculates and applies the transformation matrix for 3D rotation effects.\r\n   *\r\n   * @param ctx The canvas context to apply the transform to\r\n   * @param x The x position to translate to\r\n   * @param y The y position to translate to\r\n   */\r\n  private apply3DTransform(ctx: CanvasRenderingContext2D, x: number, y: number): void {\r\n    if (this.config.enable3DRotation) {\r\n      const { rotationX, rotationY } = this.params\r\n      const rotation = this.params.rotation || 0\r\n\r\n      // Convert degrees to radians\r\n      const radX = (rotationX * Math.PI) / 180\r\n      const radY = (rotationY * Math.PI) / 180\r\n      const radZ = (rotation * Math.PI) / 180\r\n\r\n      // Calculate 3D rotation matrices\r\n      const cosX = Math.cos(radX)\r\n      const sinX = Math.sin(radX)\r\n      const cosY = Math.cos(radY)\r\n      const sinY = Math.sin(radY)\r\n      const cosZ = Math.cos(radZ)\r\n      const sinZ = Math.sin(radZ)\r\n\r\n      // Combined rotation matrix (Z * Y * X)\r\n      // This creates a 3D tumbling effect\r\n      const a = cosZ * cosY\r\n      const b = cosZ * sinY * sinX - sinZ * cosX\r\n      const c = cosZ * sinY * cosX + sinZ * sinX\r\n      const d = sinZ * cosY\r\n\r\n      // Apply the transform\r\n      // The arguments for setTransform are: a, b, c, d, e, f\r\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\r\n      ctx.setTransform(a, b, c, d, x, y)\r\n    } else {\r\n      // Original 2D rotation (only for images)\r\n      const rotation = this.params.rotation || 0\r\n      const radian = (rotation * Math.PI) / 180\r\n      const cos = Math.cos(radian)\r\n      const sin = Math.sin(radian)\r\n\r\n      // The arguments for setTransform are: a, b, c, d, e, f\r\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\r\n      ctx.setTransform(cos, sin, -sin, cos, x, y)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws a circular snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config does not have images.\r\n   *\r\n   * This method assumes that a path has already been started on the canvas.\r\n   * `ctx.beginPath()` should be called before calling this method.\r\n   *\r\n   * After calling this method, the fillStyle should be set to the snowflake's\r\n   * color and `ctx.fill()` should be called to fill the snowflake.\r\n   *\r\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\r\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawCircle(ctx: CanvasRenderingContext2D): void {\r\n    // If 3D rotation is enabled, we need to draw individually with transform\r\n    // This method is called when 3D rotation is disabled (for performance)\r\n    ctx.moveTo(this.params.x, this.params.y)\r\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi)\r\n  }\r\n\r\n  /**\r\n   * Draws a circular snowflake with 3D rotation effect to the canvas.\r\n   *\r\n   * This method is used when 3D rotation is enabled and images are not being used.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   * @param color The color to fill the circle with\r\n   */\r\n  public drawCircle3D(ctx: CanvasRenderingContext2D, color: string): void {\r\n    const { x, y, radius } = this.params\r\n\r\n    ctx.save()\r\n\r\n    // Apply 3D rotation transform\r\n    if (this.config.enable3DRotation) {\r\n      this.apply3DTransform(ctx, x, y)\r\n    } else {\r\n      // No transform needed for circles without 3D rotation\r\n      ctx.translate(x, y)\r\n    }\r\n\r\n    // Draw the circle\r\n    ctx.beginPath()\r\n    ctx.arc(0, 0, radius, 0, twoPi)\r\n    ctx.fillStyle = color\r\n    ctx.fill()\r\n\r\n    ctx.restore()\r\n  }\r\n\r\n  /**\r\n   * Draws an image-based snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config has images.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawImage(ctx: CanvasRenderingContext2D): void {\r\n    const { x, y, radius } = this.params\r\n\r\n    // Save the current state to avoid affecting other drawings\r\n    ctx.save()\r\n\r\n    // Set opacity if needed\r\n    if (this.params.opacity !== 1) {\r\n      ctx.globalAlpha = this.params.opacity\r\n    }\r\n\r\n    // Apply 3D or 2D rotation transform\r\n    this.apply3DTransform(ctx, x, y)\r\n\r\n    // Draw the image with the center of the image at the center of the current location\r\n    const image = this.getImageOffscreenCanvas(this.image!, radius)\r\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius)\r\n\r\n    // Restore the transform\r\n    ctx.restore()\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}