{"ast":null,"code":"import _objectSpread from \"/home/kvm-06/github/flork-meme-bank/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _SnowfallCanvas_ctx, _SnowfallCanvas_canvas;\nimport Snowflake, { defaultConfig } from './Snowflake.js';\nimport { targetFrameTime } from './config.js';\nexport class SnowfallCanvas {\n  get ctx() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_ctx, \"f\");\n  }\n  get canvas() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_canvas, \"f\");\n  }\n  set canvas(canvas) {\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n  }\n  constructor(canvas, config) {\n    this.lastUpdate = Date.now();\n    this.snowflakes = [];\n    _SnowfallCanvas_ctx.set(this, void 0);\n    _SnowfallCanvas_canvas.set(this, void 0);\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n    this.config = _objectSpread(_objectSpread({\n      snowflakeCount: 150\n    }, defaultConfig), config);\n    this.snowflakes = [];\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config);\n    this.play();\n  }\n  /**\n   * Updates the config used for the snowfall animation, if the number of snowflakes\n   * has changed then this will create new or remove existing snowflakes gracefully\n   * to retain the position of as many existing snowflakes as possible.\n   */\n  updateConfig(config) {\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length;\n    if (sizeDifference > 0) {\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)];\n    }\n    if (sizeDifference < 0) {\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount);\n    }\n    for (const snowflake of this.snowflakes) {\n      snowflake.updateConfig(this.config);\n    }\n  }\n  /**\n   * Updates the location of each snowflake based on the number of frames passed then\n   * clears the canvas and draws each snowflake.\n   */\n  render() {\n    let framesPassed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const {\n      ctx,\n      canvas,\n      snowflakes\n    } = this;\n    if (!ctx || !canvas) return;\n    const {\n      offsetWidth,\n      offsetHeight\n    } = canvas;\n    // Update the position of each snowflake\n    for (const snowflake of snowflakes) {\n      snowflake.update(offsetWidth, offsetHeight, framesPassed);\n    }\n    // Render the snowflakes\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight);\n    // If using images, draw each image individually\n    if (this.config.images && this.config.images.length > 0) {\n      for (const snowflake of snowflakes) {\n        snowflake.drawImage(ctx);\n      }\n      return;\n    }\n    // Not using images\n    // If 3D rotation is enabled, draw each circle individually with transform\n    if (this.config.enable3DRotation) {\n      for (const snowflake of snowflakes) {\n        snowflake.drawCircle3D(ctx, this.config.color);\n      }\n    } else {\n      // Draw circles in a single path for better performance\n      ctx.beginPath();\n      for (const snowflake of snowflakes) {\n        snowflake.drawCircle(ctx);\n      }\n      ctx.fillStyle = this.config.color;\n      ctx.fill();\n    }\n  }\n  /**\n   * The animation loop, will calculate the time since the last render and update\n   * the position of the snowflakes appropriately before queueing another frame.\n   */\n  loop() {\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\n    const now = Date.now();\n    const msPassed = Date.now() - this.lastUpdate;\n    this.lastUpdate = now;\n    // Frames that would have passed if running at 60 fps\n    const framesPassed = msPassed / targetFrameTime;\n    this.render(framesPassed);\n    this.animationFrame = requestAnimationFrame(() => this.loop());\n  }\n  /** Start the animation playing. */\n  play() {\n    this.loop();\n  }\n  /** Pause the animation. */\n  pause() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = undefined;\n    }\n  }\n}\n_SnowfallCanvas_ctx = new WeakMap(), _SnowfallCanvas_canvas = new WeakMap();\nexport default SnowfallCanvas;","map":{"version":3,"names":["Snowflake","defaultConfig","targetFrameTime","SnowfallCanvas","ctx","__classPrivateFieldGet","_SnowfallCanvas_ctx","canvas","_SnowfallCanvas_canvas","__classPrivateFieldSet","getContext","constructor","config","lastUpdate","Date","now","snowflakes","set","_objectSpread","snowflakeCount","createSnowflakes","play","updateConfig","sizeDifference","length","slice","snowflake","render","framesPassed","arguments","undefined","offsetWidth","offsetHeight","update","setTransform","clearRect","images","drawImage","enable3DRotation","drawCircle3D","color","beginPath","drawCircle","fillStyle","fill","loop","msPassed","animationFrame","requestAnimationFrame","pause","cancelAnimationFrame"],"sources":["/home/kvm-06/github/flork-meme-bank/node_modules/react-snowfall/src/SnowfallCanvas.ts"],"sourcesContent":["import Snowflake, { SnowflakeConfig, defaultConfig } from './Snowflake.js'\r\nimport { targetFrameTime } from './config.js'\r\n\r\nexport interface SnowfallCanvasConfig extends SnowflakeConfig {\r\n  /**\r\n   * The number of snowflakes to be rendered.\r\n   *\r\n   * The default value is 150.\r\n   */\r\n  snowflakeCount: number\r\n}\r\n\r\nexport class SnowfallCanvas {\r\n  private lastUpdate = Date.now()\r\n  private snowflakes: Snowflake[] = []\r\n  private config: SnowfallCanvasConfig\r\n\r\n  #ctx: CanvasRenderingContext2D | null\r\n  get ctx() {\r\n    return this.#ctx\r\n  }\r\n\r\n  #canvas: HTMLCanvasElement\r\n  get canvas() {\r\n    return this.#canvas\r\n  }\r\n  set canvas(canvas: HTMLCanvasElement) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n  }\r\n\r\n  constructor(canvas: HTMLCanvasElement, config: Partial<SnowfallCanvasConfig>) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n    this.config = { snowflakeCount: 150, ...defaultConfig, ...config }\r\n    this.snowflakes = []\r\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config)\r\n    this.play()\r\n  }\r\n\r\n  /**\r\n   * Updates the config used for the snowfall animation, if the number of snowflakes\r\n   * has changed then this will create new or remove existing snowflakes gracefully\r\n   * to retain the position of as many existing snowflakes as possible.\r\n   */\r\n  updateConfig(config: Partial<SnowfallCanvasConfig>) {\r\n    this.config = { ...this.config, ...config }\r\n\r\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length\r\n\r\n    if (sizeDifference > 0) {\r\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)]\r\n    }\r\n\r\n    if (sizeDifference < 0) {\r\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount)\r\n    }\r\n\r\n    for (const snowflake of this.snowflakes) {\r\n      snowflake.updateConfig(this.config)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the location of each snowflake based on the number of frames passed then\r\n   * clears the canvas and draws each snowflake.\r\n   */\r\n  private render(framesPassed = 1) {\r\n    const { ctx, canvas, snowflakes } = this\r\n\r\n    if (!ctx || !canvas) return\r\n\r\n    const { offsetWidth, offsetHeight } = canvas\r\n\r\n    // Update the position of each snowflake\r\n    for (const snowflake of snowflakes) {\r\n      snowflake.update(offsetWidth, offsetHeight, framesPassed)\r\n    }\r\n\r\n    // Render the snowflakes\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\r\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight)\r\n\r\n    // If using images, draw each image individually\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawImage(ctx)\r\n      }\r\n      return\r\n    }\r\n\r\n    // Not using images\r\n    // If 3D rotation is enabled, draw each circle individually with transform\r\n    if (this.config.enable3DRotation) {\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawCircle3D(ctx, this.config.color!)\r\n      }\r\n    } else {\r\n      // Draw circles in a single path for better performance\r\n      ctx.beginPath()\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawCircle(ctx)\r\n      }\r\n      ctx.fillStyle = this.config.color!\r\n      ctx.fill()\r\n    }\r\n  }\r\n\r\n  private animationFrame: number | undefined\r\n\r\n  /**\r\n   * The animation loop, will calculate the time since the last render and update\r\n   * the position of the snowflakes appropriately before queueing another frame.\r\n   */\r\n  private loop() {\r\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\r\n    const now = Date.now()\r\n    const msPassed = Date.now() - this.lastUpdate\r\n    this.lastUpdate = now\r\n\r\n    // Frames that would have passed if running at 60 fps\r\n    const framesPassed = msPassed / targetFrameTime\r\n\r\n    this.render(framesPassed)\r\n\r\n    this.animationFrame = requestAnimationFrame(() => this.loop())\r\n  }\r\n\r\n  /** Start the animation playing. */\r\n  play() {\r\n    this.loop()\r\n  }\r\n\r\n  /** Pause the animation. */\r\n  pause() {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame)\r\n      this.animationFrame = undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport default SnowfallCanvas\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}